#!/bin/bash

shopt -s dotglob
CALLER_DIR=`pwd`

###############################################################################
### These may be called in subsequent functions and should be defined first ###

has_file () { [ -f "$1" ] && echo has || echo no; }
has_dir ()  { [ -d "$1" ] && echo has || echo no; }

printarr () {
	# Send in your array like : printarr arr[@]
	declare -a arg_arr=("${!1}")  # weird trick
	printf '%s\n' "${arg_arr[@]}" # printf on separate lines
}

index_of () {
	# Send in your array and value like:
	#	index_of arr[@] "$value"
	
	declare -a arg_arr=("${!1}")  # weird trick
	value="$2"
	result=-1
	for i in "${!arg_arr[@]}"; do
		if [ "${arg_arr[$i]}" = "$value" ]; then
			result="$i"
			break
		fi
	done
	echo $result
}

# short instruction for those already set up:
display_how_to () {
	echo "You'll want to thoroughly set up your .gitignore before committing anything, "
	echo "then use your normal git command for all task except \`git init\`. Instead:"
	printf "\t$ gits init <REPONAME>\n"
	echo "the normal git command only applies only to the active git which can be selected with:"
	printf "\t$ gits sel <REPONAME>\n"
	echo "switching active gits not only brings .git/ and .gitignore in and out. If a file"
	echo "beginning with 'README.' are found at the repository root it will be moved as well."
	echo "You can switch and run a command in a single line with this:"
	printf "\t$ gits <REPONAME> <whatever>\n"
	echo "where '<whatever>' would be whatever you would type after \`git\`"
}

###############################################################################
######        Gathering Information                                      ######

# we will have a directory to hold inactive .git/ and .gitignore, each in 
# separate folders there. The empty one is interpreted as the active one in 
# which case we'd expect to see a .git/ and .gitignore at the root directory. 

# for the root directory and each directory within our holding directory 
# we will have a single string to track it's 4 possible states
# Two are healthy   - "has .git, has .gitignore"    "no .git, no .gitignore"
# Two are unhealthy - "no .git, has .gitignore"     "has .git, no .gitignore"

# the root's state will be held in:   activegit_stat
# the rest will be in this array:     gitpaths_stats

# this is always run to get name of dir holding inactive gits, check root status
# add queue up messages of notices for missing .git/ or .gitignore:
gather_basic_info () {

	if [ -d "$CALLER_DIR"/*"_gits/" ]; then 
		GITS_DIR="$(echo "$CALLER_DIR"/*"_gits")" # directory path to store gits
		GITS_DIR_BN="$(basename "$GITS_DIR")"    # just directory name for GITS_DIR
	else
		GITS_DIR=no
		GITS_DIR_BN=no
	fi
	activegit_stat=`has_dir "$CALLER_DIR"/.git`" .git, "
	activegit_stat+=`has_file "$CALLER_DIR"/.gitignore`" .gitignore"
	# activegit_stat - looks at the top dir of the project and 
	# 	stores a string which could be any of 4 states:
	# 	"no .git, no .gitignore" OR "has .git, has .gitignore"
	# 	which are "healthy", or:
	if [ "$activegit_stat" = "has .git, no .gitignore" ]; then
		notices+=("NOTICE: missing .gitignore was added to active git")
		touch "$CALLER_DIR/.gitignore"
		echo "/$GITS_DIR_BN/ # auto-added by gits command" >> "$CALLER_DIR/.gitignore"
	elif [ "$activegit_stat" = "no .git, has .gitignore" ]
		notices+=("NOTICE: .gitignore found at project root but no .git directory!")
	fi
}

# gather_gits_info gets infomation about contents of _gits/ and should always
# run whenever the gits command is run, except for with gits setup:
gather_gits_info () {
	# run gather_basic_info here

	if [ "GITS_DIR" = "no" ]; then 
		echo "no directory ending with _gits was found! Try running \`gits setup\`"
		echo "or type \`git help\`"
	else
		gitpaths=() # array of all dir paths in GITS_DIR
		gitlist=()  # same as above but just the names
		nogit=()   # array of all dir name in GITS_DIR that lack .git
		gitpaths_stats=() # array of stats (like in activegit_stat) for each directory
		# in GITS_DIR with positions matching gitpaths.

		i=1
		for dir in "$GITS_DIR"/*/ ; do
			gitpaths+=("${dir%*/}") # array of full paths of every dir in GITS_DIR
			dirstat=`has_dir "$dir"/.git`" .git, "
			dirstat+=`has_file "$dir"/.gitignore`" .gitignore"
			reponame="$(basename "${dir%*/}")"
			gitlist+=("$reponame")

			[ "$1" = "echo list" ] && echo "$i. $reponame"

			if [ "$dirstat" = "no .git"* ]; then 
				nogit+=("$reponame")
			elif [ "$dirstat" = "has .git, no .gitignore"  ]; then
				notices+=("NOTICE: missing .gitignore was added to $GITS_DIR_BN/$reponame")
				touch "$dir/.gitignore"
				echo "/$GITS_DIR_BN/ # auto-added by gits command" >> "$dir/.gitignore"
			fi
			gitpaths_stats+=("$stat")
		done
		NUM_OF_GITS=${#gitpaths[@]}
		NUM_OF_INACTIVE=${#nogit[@]}

		# These are the real show-stopper errors! If they are added we should exit

		ORPHAN_MSG="ERROR: The active git is not recognized as one of the named gits "
		ORPHAN_MSG+="since none of the directories in $GITS_DIR_BN is lacking a .git/"
		ORPHAN_SOLUTION="Run mkdir $GITS_DIR_BN/DESIREDNAME"

		UNCLEAR_MSG="ERROR: The active git name is unclear since $GITS_DIR_BN shows more "
		UNCLEAR_MSG+="than one possible active git by lacking a .git/ directory. They are:"

		MISSINGGIT_MSG="ERROR: There is no active git but $GITS_DIR_BN shows one or more as "
		MISSINGGIT_MSG+="active by not containing a .git/ directory. They are:"

		NOSOLUTION="Now exiting..."

		if [ "$activegit_stat" = "has .git"* ]; then 
			if [ "$NUM_OF_INACTIVE" -eq "0"]; then
				notices=("${notices[@]}" "$ORPHAN_MSG" "$ORPHAN_SOLUTION")
				printf '%s\n' "${notices[@]}"
				exit 1
			elif [ "$NUM_OF_INACTIVE" -gt "1"]; then 
				notices=("${notices[@]}" "$UNCLEAR_MSG" "${nogit[@]}" "$NOSOLUTION")
				printf '%s\n' "${notices[@]}"
				exit 1
			else
				ACTIVE_GIT_NAME="${nogit[0]}"
				printf '%s\n' "${notices[@]}"
				notices=() # cleared out notices is a signal we can proceed
				[ "$2" = "echo active" ] && echo "Currently Active: $ACTIVE_GIT_NAME"
			fi
		# (fyi: this elif won't run if .git was found at root)
		elif [ "$NUM_OF_INACTIVE" -gt "1"]; then 
			notices=("${notices[@]}" "$MISSINGGIT_MSG" "${nogit[@]}" "$NOSOLUTION")
			printf '%s\n' "${notices[@]}"
			exit 1
		else
			printf '%s\n' "${notices[@]}"
			printf '%s\n' "${notices[@]}"
			notices=() # cleared out notices is a signal we can proceed
			[ "$2" = "echo active" ] && echo "Currently Active: none"
		fi
	fi
}

###############################################################################
######            Running Actions                                        ######

# setup will create the _gits/ dir and can't be run until 
# gather_basic_info has been called but can be before any git init.
run_setup () {
	if [ "$GITS_DIR" = "no" ]; then 
		echo "A directory ending with '_gits' needs to be created."
		echo "Enter something to prepend the name (start with . to make hidden)"
		echo "or just hit enter to name it _gits: "
		read input
		GITS_DIR_BN="${input}_gits"
		GITS_DIR="$CALLER_DIR/$GITS_DIR_BN"
		mkdir $GITS_DIR

		if [ "$activegit_stat" = *"has .git" ]; then 
			if [ "$activegit_stat" = "has .gitignore"* ]; then 
				echo ".git and .gitignore were found at this location."
				echo "gits need to assign it a name and add $GITS_DIR_BN to .gitignore"
			else
				echo ".git was found at this location."
				echo "gits need to assign it a name and add $GITS_DIR_BN to a new .gitignore"
			fi
			echo "enter a name (must be a valid directory name): "
			read reponame
			new_dir_in_gits="$GITS_DIR/$reponame"
			mkdir "$GITS_DIR/$reponame"
			touch "$CALLER_DIR/.gitignore"
			echo "/$GITS_DIR_BN/ # auto-added by gits command" >> "$CALLER_DIR/.gitignore"

			# let's do this just as a failsafe to keep track of things:
			echo "$reponame" >> "$CALLER_DIR/.git/description"
		fi
		echo "Done."
		display_how_to
	else
		echo "This directory already has a gits directory ($GITS_DIR_BN)"
	fi
}

run_init() {
	if [ -z "$1" ]; then 
		echo "you must supply a chosen name as the second argument"
		exit 0
	else
		NEWGIT="$1"
		shift
	fi

	gather_basic_info
	gather_gits_info

	index=`index_of gitlist[@] "$NEWGIT"`
	if [ "$index" -ne "-1" ]; then 
		echo "The choosen name is already taken"
		exit 0
	fi

	if [ ! -z "$ACTIVE_GIT_NAME" ]; then
		mv "$CALLER_DIR/.git" "$GITS_DIR/$ACTIVE_GIT_NAME/.git"
		mv "$CALLER_DIR/.gitignore" "$GITS_DIR/$ACTIVE_GIT_NAME/.gitignore"
		if [ -f "$CALLER_DIR/README."* ]; then 
			rm_path="$(echo "$CALLER_DIR/README."*)"
			rm_file="$(basename "$RM_PATH")"
			mv "$rm_path" "$GITS_DIR/$ACTIVE_GIT_NAME/$rm_file"
		fi
	fi

	mkdir "$GITS_DIR/$NEWGIT"
	cd "$CALLER_DIR"
	git init "$@"
	touch .gitignore
	echo "/$GITS_DIR_BN/ # auto-added by gits command" >> .gitignore
}

run_select () {
	gather_basic_info
	gather_gits_info

	GIT2GET="$1"

	index=`index_of gitlist[@] "$GIT2GET"`
	if [ "$index" -eq "-1" ]; then 
		echo "That git name was not found in $GITS_DIR_BN"
		echo "To list out all names run \`gits list\` or \`gits info\`"
		exit 0
	fi

	mv "$CALLER_DIR/.git" "$GITS_DIR/$ACTIVE_GIT_NAME/.git"
	mv "$CALLER_DIR/.gitignore" "$GITS_DIR/$ACTIVE_GIT_NAME/.gitignore"
	if [ -f "$CALLER_DIR/README."* ]; then 
		rm_path="$(echo "$CALLER_DIR/README."*)"
		rm_file="$(basename "$RM_PATH")"
		mv "$rm_path" "$GITS_DIR/$ACTIVE_GIT_NAME/$rm_file"
	fi

	mv "$GITS_DIR/$GIT2GET/.git" "$CALLER_DIR/.git"
	mv "$GITS_DIR/$GIT2GET/.gitignore" "$CALLER_DIR/.gitignore"
	if [ -f "$GITS_DIR/$GIT2GET/README."* ]; then 
		rm_path="$(echo "$GITS_DIR/$GIT2GET/README."*)"
		rm_file="$(basename "$RM_PATH")"
		mv "$rm_path" "$CALLER_DIR/$rm_file"
	fi
	echo "The active git is now: $GIT2GET"
}

###############################################################################
######            Parsing Arguments                                      ######

if [ $# -eq 0 ]; then
	gather_basic_info
	gather_gits_info "dont list" "echo active"
else
	case "$1" in
	init)
		shift
		run_init "$@"
		;;
	sel)
		shift
		run_select "$1"
		;;
	help)
		echo "gits allow you to have multiple git repositories from the same main working directory."
		echo "You will have an 'active git' which is the normal .git/ and .gitignore at this root"
		echo "but also a directory (with a name ending _gits) which contains inactive .git and .gitignore,"
		echo "each in separate folders. The difference between each repositories is controlled with .gitignore,"
		echo "which can be set up to ignore different things or even using a 'whitelisting' method"
		echo; display_how_to; echo; echo "to get started, run \`gits setup\` or visit the GitHub"
		;;
	setup)
		gather_basic_info
		run_setup
		;;
	list)
		gather_basic_info
		gather_gits_info "echo list" "echo active"
		;;
	count)
		gather_basic_info
		gather_gits_info "dont list" "echo active"
		echo "$NUM_OF_INACTIVE inactive gits, $NUM_OF_GITS in total"
		;;
	info)
		gather_basic_info
		gather_gits_info "echo list" "echo active"
		echo "$NUM_OF_INACTIVE inactive gits, $NUM_OF_GITS in total"
		;;
	*)
		run_select "$1"
		shift
		git "$@"
		;;
	esac
fi
