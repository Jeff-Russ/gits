#!/bin/bash
# 
shopt -s dotglob # for access to hidden items

###############################################################################
######                Arg Parsing Function                               ######

# main the only entry point and is passed "$@" without modification
main () {

	if num_eq "$#" "0"; then
		obligatory_stuff
		printarr ALL_GIT_NAMES[@]
		echo "Active: $ACTIVE_GIT_NAME"
		echo "For help run: gits --help"

	elif str_eq "$1" "-"* ; then # parse flags
		case "$1" in
		--help)
			printf "\n\t\tgits - https://github.com/Jeff-Russ/gits\n\n"
			echo "gits is a wrapper around the git command that allows you to toggle between multiple git "
			echo "repositories from the same main working directory. Each is assigned a name and .gitignore."
			echo "(and possibly README.*) each in separate folders. The difference between each repositories is"
			echo "controlled with .gitignore, which can be set up to ignore different things or even using a "
			printf "'whitelisting' method.\n\n"
			display_how_to
			printf "To get started, run \`gits setup\` or visit the GitHub\n\n\t\t~Jeff Russ\n\n"
			;;
		esac

	else # then the first arg is either name to switch to or a new name to create
		select_git "$1"
		shift
		not_z "$1" git "$CUSTOM_CMD" "$@"
	fi
}

###############################################################################
######                Function to Switch + Create Gits                   ######

# This function takes one arg: a gits repository name
# If the name exists and is inactive it's made active and CUSTOM_CMD is set
# If it's already active, just set CUSTOM_CMD
# If the name is not found, the user is prompted, it's created then switched to

CUSTOM_CMD="" # this global might be set below. It will be insert right after git
select_git () {
	local repo_to_use="$1"

	if arr_has_value ALL_GIT_NAMES[@] "$repo_to_use"; then # If this is not a new name
		if str_ne "$ACTIVE_GIT_NAME" "$repo_to_use"; then  # AND it's not the active one
			# then move the active git out of the way
			not_z "$ACTIVE_GIT_NAME" && mv_git "$WD" "$WD/$GITS_FOLDER/$ACTIVE_GIT_NAME"
		fi
		# now that there is no active git let's fetch the one selected
		mv_git "$WD/$GITS_FOLDER/$repo_to_use" "$WD"
		# and update information
		ACTIVE_GIT_NAME="$repo_to_use"

		get_line_after "$WD/.gitignore" "#CUSTOM_CMD="


	else # the name entered does not exist and should be created

		# move out .git .gitignore and README.* if found at root dir
		not_z "$ACTIVE_GIT_NAME" && mv_git "$WD" "$WD/$GITS_FOLDER/$ACTIVE_GIT_NAME"
		mkdir "$WD/$GITS_FOLDER/$repo_to_use"

		ACTIVE_GIT_NAME="$newreponame"
		local insert=`echo_ignore_insert "$ACTIVE_GIT_NAME"`
		printf "$insert" >> "$WD/.gitignore"
	fi
}


###############################################################################
######                Almost Always Run Function                         ######

# The obligatory_stuff fuction will
#	1. fetch all needed information
#	2. ask and set up the gits directory if not found
#	3. register an active git if found
#	4. update all information

# The "information" set in and needed elsewhere is the following globals:

WD=`pwd` # might as well just set this here. It's the caller's full path
GITS_FOLDER=""        # directory path to store gits if found (not full path)
ACTIVE_GIT_NAME=""    # directory within $WD/$GITS_FOLDER that will hold active git
ALL_GIT_NAMES=()      # array of all dir in $WD/$GITS_FOLDER that have .git
INACTIVE_GIT_NAMES=() # array of all dir name in $WD/$GITS_FOLDER that lack .git
IGN_INSERT=""         # text to be added to ignore (needs other vars set)

obligatory_stuff () {

	active_git_path="" # full path to active .git if found
	active_ign_path="" # full path to active .gitignore if found

	dir_found "$WD/.git"; && active_git_path="$WD/.git"
	file_found "$WD/.gitignore" && active_ign_path="$WD/.gitignore"

	if dir_found "$WD"/*"_gits/"; then

		GITS_FOLDER="$(basename "$(echo "$WD"/*_gits)")"
		IGN_INSERT="/$GITS_FOLDER/ # auto-added by gits command"
		i=0
		shopt -s nullglob # without this when $WD/$GITS_FOLDER is empty loop stills runs 1x
		for dir in "$WD/$GITS_FOLDER"/*/ ; do 
			shopt -u nullglob

			reponame="$(basename "${dir%*/}")"
			ALL_GIT_NAMES+=("$reponame")

			if dir_missing "$dir/.git"; then 
				INACTIVE_GIT_NAMES+=("$reponame")
			elif file_missing "$dir/.gitignore"; then
				local insert=`echo_ignore_insert "$reponame"`
				printf "$insert" >> "$dir/.gitignore"
			fi
			i=$((i+1))
			str_eq "$1" "echo list" && echo "$i. $reponame"
		done

		num_of_inactive=${#INACTIVE_GIT_NAMES[@]} # used only for error handling below
		
		if not_z "$active_git_path"; then # exit 1 for show-stopper errors
			if num_eq "$num_of_inactive" "0"; then
				printf "ERROR: The active git is not recognized as one of the named gits "
				printf "since none of the directories in $GITS_FOLDER is lacking a .git/\n"
				printf "Choose a name for it and run: mkdir $GITS_FOLDER/DESIREDNAME/n"
				printf "Now exiting..."; exit 1
			elif num_gt "$num_of_inactive" "1"; then 
				printf "ERROR: The active git name is unclear since $GITS_FOLDER shows more "
				printf "than one possible active git by lacking a .git/ directory. They are:\n"
				printf '%s\n' "${notices[@]}"
				printf "Now exiting..."; exit 1
			else # there is a valid active git and everything is fine
				ACTIVE_GIT_NAME="${INACTIVE_GIT_NAMES[0]}"
				if is_z "$active_ign_path"; then # might as well make sure it has the insert
					active_ign_path="$WD/.gitignore"
					local insert=`echo_ignore_insert "$ACTIVE_GIT_NAME"`
					printf "$insert" >> "$active_ign_path"
				fi
			fi
		elif num_gt "$num_of_inactive" "1"; then # we have no active git and there should be 1+ !!
			printf "ERROR: There is no active git but $GITS_FOLDER shows one or more as "
			printf "active by not containing a .git/ directory. They are:\n"
			printf '%s\n' "${notices[@]}"
			printf "Now exiting..."; exit 1
		else
			printf '%s\n' "${notices[@]}"
			notices=() # cleared out notices is a signal we can proceed
			str_eq "$2" "echo active" && echo "Currently Active: none"
		fi

	else # gits was not set up here
		echo "You are about to initialize mulitiple git management from this top-level directory"
		echo "Hit [ENTER] to proceed, dot (.) [ENTER] to proceed as hidden or anything else to abort"
		read prepend

		not_z prepend && str_ne "." && exit 0 # get me out

		GITS_FOLDER="${prepend}_gits"

		mkdir "$WD/$GITS_FOLDER"

		if not_z "$active_git_path"; then # gits was not set up but git was
			printf "\nA git repository was found at your location.\n"
			printf "\`gits\` need to assign a name for it so we can keep track.\n"
			printf "This name doen't need to match any name used externally"
			printf "Enter a gits repository name (must also valid as a directory name): "
			read newreponame
			until mkdir "$WD/$GITS_FOLDER/$newreponame"; do
				printf "Name failed. Enter a different name: "
				read newreponame
			done

			ACTIVE_GIT_NAME="$newreponame"
			local insert=`echo_ignore_insert "$ACTIVE_GIT_NAME"`

			if is_z "$active_ign_path"; then
				active_ign_path="$WD/.gitignore"
				printf "$insert" >> "$active_ign_path"
			elif file_lacks_line_starting "$WD/.gitignore" "/$GITS_FOLDER"; then
				# it would be stange if it had the line but might as well not create dups
				printf "$insert" >> "$active_ign_path"
			fi
		fi
	fi
}

###############################################################################
######           Re-useable Functions for Other Tasks                    ######

mv_git () {
	FROM="$1"; TO="$2"
	mv "$FROM/.git" "$TO/.git"
	mv "$FROM/.gitignore" "$TO/.gitignore"
	if file_found "$FROM/README."* ; then 
		rm_path="$(echo "$FROM/README."*)"
		rm_file="$(basename "$RM_PATH")"
		mv "$rm_path" "$TO/$rm_file"
	fi
}
echo_ignore_insert () {
	echo "/$GITS_FOLDER/ # auto-added by gits for '$1'\n#CUSTOM_CMD="
}
display_how_to () {
	local st="You'll want to thoroughly set up your .gitignore before committing anything, "
	st+="then use your normal git command for all task except \`git init\`. Instead:\n\n"
	st+="\t$ gits NAME\n\n"
	st+="The normal git command only applies only to the active git which can be changed with:\n\n"
	st+="\t$ gits NAME>\n\n"
	st+="You can switch and run a normal command in a single line with this:\n\n"
	st+="\t$ gits <REPONAME> <whatever>\n\n"
	st+="where '<whatever>' would be whatever you would type after \`git\`\n"
	printf "$st" | fold -w 80 -s
}
printwrap () {
	[[ -z "$2" ]] && w="80" || w="$2"
	printf "$1\n" | fold -w $w -s
}
arr_has_value () { # Send in array + value like: index_of arr[@] "$value"
	declare -a arg_arr=("${!1}")  # weird trick
	for i in "${!arg_arr[@]}"; do
		str_eq "${arg_arr[$i]}" "$2" && return 0
	done
	return 1
}
printarr () { # Send in your array like : printarr arr[@]
	declare -a arg_arr=("${!1}")  # weird trick
	printf '%s\n' "${arg_arr[@]}" # printf on separate lines
}
file_has_line_starting () {
	grep -FExq "^$2.*$" "$1" && return 0 || return 1
}
file_lacks_line_starting () {
	grep -FExq "^$2.*$" "$1" && return 1 || return 0
}
get_line_after () {
	file="$1"
	pattern="$2"
	size=${#pattern} 
	full_line=`grep "^$pattern" "$file"`
	echo "${full_line:12}"
}
file_found () { n-f "$1" ] && return 0 || return 1; }
dir_found ()  { [ -d "$1" ] && return 0 || return 1; }
str_eq () { [[ "$1" = "$2" ]] && return 0 || return 1; }
str_ne () { [[ "$1" = "$2" ]] && return 1 || return 0; }
is_z () { [[ -z "$1" ]] && return 0 || return 1; }
not_z () { [[ -z "$1" ]] && return 1 || return 0; }
num_eq () { [ "$1" -eq "$2" ] && return 0 || return 1; }
num_gt () { [ "$1" -gt "$2" ] && return 0 || return 1; }


###############################################################################
######            EXECUTION STARTS HERE                                  ######

main "$@"

